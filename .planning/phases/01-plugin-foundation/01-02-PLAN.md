---
phase: 01-plugin-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - reference/terminology.md
  - reference/plain-language-guide.md
  - reference/verification-patterns.md
  - reference/context-management.md
autonomous: true

must_haves:
  truths:
    - "All skills and agents can reference a single terminology source for Director vocabulary"
    - "Plain-language rules exist so agents never use jargon in user-facing output"
    - "Verification patterns are documented for the verifier agent to follow"
    - "Context assembly rules are documented for the builder agent to follow"
  artifacts:
    - path: "reference/terminology.md"
      provides: "Director vocabulary rules and term mappings"
      contains: "Goal"
    - path: "reference/plain-language-guide.md"
      provides: "Rules for communicating with vibe coders"
      contains: "jargon"
    - path: "reference/verification-patterns.md"
      provides: "Stub, orphan, and wiring detection patterns"
      contains: "stub"
    - path: "reference/context-management.md"
      provides: "Fresh agent window assembly rules and XML boundary tag conventions"
      contains: "XML"
  key_links:
    - from: "reference/terminology.md"
      to: "skills and agents"
      via: "referenced in skill instructions and agent prompts"
      pattern: "reference/terminology"
---

<objective>
Create the four reference documents that skills and agents load for domain knowledge -- terminology rules, plain-language communication guidelines, verification patterns, and context management conventions.

Purpose: These docs are the shared knowledge base. Every agent prompt and skill instruction references them. Without these, agents would each need to duplicate vocabulary rules, communication guidelines, and verification patterns, leading to inconsistency.
Output: Four reference documents in `reference/` that define Director's internal guidelines.
</objective>

<execution_context>
@/Users/noahrasheta/.claude/get-shit-done/workflows/execute-plan.md
@/Users/noahrasheta/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-plugin-foundation/01-RESEARCH.md
@.planning/phases/01-plugin-foundation/01-CONTEXT.md
@docs/design/PRD.md (Section 5 for terminology, Section 9.4 for hybrid formatting)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create terminology and plain-language reference docs</name>
  <files>reference/terminology.md, reference/plain-language-guide.md</files>
  <action>
Create `reference/terminology.md` -- Director's vocabulary rules:
- Director's hierarchy: Project > Goals > Steps > Tasks > Actions (Actions are invisible to users)
- Term mapping table: What Director says vs what developers would say
  - Goal = Milestone/Epic
  - Step = Phase/Sprint
  - Task = Ticket/Issue/Story
  - Action = Sub-task (invisible to user)
  - Vision = Spec/PRD/Requirements
  - Gameplan = Roadmap/Backlog
  - Launch = Deploy/Release/Ship
  - "Progress saved" = Committed
  - "Going back" = Reverted
  - "Needs X first" = Has dependency on X
  - "Needs attention" = Has issues/failing
  - "Ready" = No blockers, can start
- Terms to NEVER use in user-facing output: dependency, artifact, integration, deployment pipeline, CI/CD, migration, schema, endpoint, route, middleware, ORM, repository, branch, merge, commit, SHA, diff, stack trace, exception, runtime, build step, compile
- Terms that are OK when explaining what was built: file, page, button, form, database, API, login, signup, dashboard, settings
- Examples of good vs bad phrasing:
  - Bad: "Task EXEC-03 has an unresolved dependency on ONBR-05"
  - Good: "This needs user authentication first. Want to set that up?"
  - Bad: "Committed 3 files to the repository"
  - Good: "Progress saved. The login page is ready."

Create `reference/plain-language-guide.md` -- how to communicate with vibe coders:
- Core principle: Vibe coders think in outcomes, not syntax. They care about WHAT it does, not HOW it's implemented.
- Rule 1: Explain outcomes, not mechanisms ("Your project can now accept payments" not "Stripe webhook handler configured")
- Rule 2: Use conversational tone, not imperative commands ("Ready to get started?" not "Run /director:onboard")
- Rule 3: When routing to another command, explain WHY then suggest ("You have a vision but no gameplan yet. Want to create one?" not "Error: no gameplan found. Run /director:blueprint")
- Rule 4: Never blame the user ("We need to set up X first" not "You forgot to run X")
- Rule 5: Celebrate progress naturally ("Step 2 is complete! You're 3 of 5 steps through your first goal." not "Step 2 status: COMPLETE. 60% progress.")
- Rule 6: When errors occur, explain what happened, why, and what to do next -- all in plain language
- Rule 7: If a command isn't functional yet, don't say "not implemented" -- say what it will do and what's available now
- Routing message template for skills: (1) State what you found, (2) Explain what needs to happen, (3) Suggest the action conversationally, (4) Wait for response
- Examples for each rule
  </action>
  <verify>
Verify both files exist and have substantive content: `wc -l reference/terminology.md reference/plain-language-guide.md` should show 40+ lines each.
Verify terminology.md contains the term mapping: `grep "Goal" reference/terminology.md`.
Verify plain-language-guide.md contains communication rules: `grep "Rule" reference/plain-language-guide.md`.
  </verify>
  <done>terminology.md maps all Director vocabulary with never-use and OK-to-use word lists plus good/bad examples. plain-language-guide.md has 7 communication rules with examples and a routing message template.</done>
</task>

<task type="auto">
  <name>Task 2: Create verification patterns and context management reference docs</name>
  <files>reference/verification-patterns.md, reference/context-management.md</files>
  <action>
Create `reference/verification-patterns.md` -- patterns for the verifier agent to detect issues:

**Stub Detection Patterns:**
- TODO/FIXME/HACK/XXX comments
- Functions returning hardcoded values that should be dynamic (e.g., `return []`, `return "placeholder"`)
- Empty function bodies, `pass` statements, `// not implemented`
- Components rendering only placeholder text or "Coming soon"
- API routes returning static/mock data
- Console.log left as debugging artifacts
- `throw new Error("not implemented")` or equivalent

**Orphan Detection Patterns:**
- Files that exist but are never imported/required by any other file
- Components defined but never rendered in a parent
- API routes defined but never called from client code
- Utility functions exported but never imported
- CSS/style files that aren't imported
- How to detect: Grep for the export name across the codebase; if no imports found, it's orphaned

**Wiring Verification Patterns:**
- Component imports match actual file exports
- API endpoint URLs in client code match actual route file paths
- Database model references match schema definitions
- Environment variables referenced in code exist in .env or config
- Navigation/routing references point to existing pages

**Reporting Format:**
- Use plain language per plain-language-guide.md
- Group by severity: "needs attention" (blocking) vs "worth checking" (informational)
- Always explain WHAT the issue is and WHERE it is, never just list file paths

Create `reference/context-management.md` -- how to assemble fresh agent context:

**Three-Layer Formatting Model:**
- Layer 1 (User-facing): Markdown files in `.director/` -- users read and edit these directly
- Layer 2 (Agent context): XML boundary tags wrapping Markdown content -- assembled at runtime, invisible to users
- Layer 3 (Machine state): JSON files (config.json, STATE.md machine-readable sections) -- neither users nor agents edit directly

**XML Boundary Tags:**
List all standard tags and what they contain:
- `<vision>` -- Contents of .director/VISION.md
- `<current_step>` -- Contents of relevant STEP.md
- `<task>` -- Task description, acceptance criteria, file scope
- `<recent_changes>` -- Recent git log summary
- `<instructions>` -- Task-specific constraints
- `<gameplan>` -- Contents of .director/GAMEPLAN.md (when needed)
- `<project_state>` -- Contents of .director/STATE.md

**Fresh Context Assembly Rules:**
- Each task gets a NEW agent context (no accumulated conversation history)
- Context includes: VISION.md (always), relevant STEP.md (always), task file (always), recent git log (always)
- Context does NOT include: other tasks, other steps, full conversation history
- Budget: Keep assembled context under 30% of window to leave room for execution
- Dynamic injection via `!`command`` syntax in SKILL.md

**Context Budget Calculator Design Notes:**
- Track approximate token count of assembled context
- Warn if context exceeds 30% of estimated window
- Truncate git log if too long (most recent N commits)
- This is design only -- implementation is Phase 4
  </action>
  <verify>
Verify both files exist: `ls reference/verification-patterns.md reference/context-management.md`.
Verify verification-patterns.md covers all three pattern types: `grep -c "Detection\|Verification" reference/verification-patterns.md` should return 3+.
Verify context-management.md documents XML tags: `grep "vision\|task\|instructions" reference/context-management.md`.
  </verify>
  <done>verification-patterns.md documents stub, orphan, and wiring detection patterns with plain-language reporting format. context-management.md documents the three-layer formatting model, XML boundary tags, fresh context assembly rules, and context budget design notes.</done>
</task>

</tasks>

<verification>
1. All four reference docs exist in `reference/`
2. terminology.md has complete vocabulary mapping with never-use and OK-to-use lists
3. plain-language-guide.md has communication rules with examples
4. verification-patterns.md covers stubs, orphans, and wiring with detection patterns
5. context-management.md documents XML tags, three-layer model, and fresh context rules
</verification>

<success_criteria>
Four reference documents exist that provide the shared knowledge base for all skills and agents. Terminology is consistent, communication rules are clear, verification patterns are actionable, and context assembly rules are documented.
</success_criteria>

<output>
After completion, create `.planning/phases/01-plugin-foundation/01-02-SUMMARY.md`
</output>
