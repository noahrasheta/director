---
phase: 04-execution
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - skills/build/SKILL.md
autonomous: true

must_haves:
  truths:
    - "Running /director:build identifies the next ready task from the gameplan hierarchy"
    - "The builder agent receives fresh context wrapped in XML boundary tags (vision, step, task, recent changes, instructions)"
    - "Each completed task produces exactly one git commit"
    - "User sees 'Progress saved' language, never git jargon"
    - "After each task, documentation sync checks .director/ docs and reports findings"
    - "Post-task summary uses paragraph + bullet list format"
    - "Context budget is estimated before spawning builder"
    - "Builder can spawn sub-agents for research, verification, and sync within a task"
  artifacts:
    - path: "skills/build/SKILL.md"
      provides: "Complete build skill with 10-step execution pipeline"
      min_lines: 250
  key_links:
    - from: "skills/build/SKILL.md"
      to: "agents/director-builder.md"
      via: "Task tool spawning"
      pattern: "Task.*director-builder"
    - from: "skills/build/SKILL.md"
      to: "agents/director-syncer.md"
      via: "Task tool spawning"
      pattern: "Task.*director-syncer"
    - from: "skills/build/SKILL.md"
      to: ".director/STATE.md"
      via: "task selection reads state"
      pattern: "STATE\\.md"
    - from: "skills/build/SKILL.md"
      to: ".director/goals/"
      via: "task file scanning"
      pattern: "\\.director/goals/"
---

<objective>
Rewrite the build skill from a routing placeholder into Director's complete execution engine.

Purpose: This is the core of Phase 4. When a user runs `/director:build`, this skill orchestrates the entire execution pipeline: routing checks, ready task identification, context assembly with XML boundary tags and budget calculator, builder agent spawning via Task tool, atomic git commit with plain-language messaging, documentation sync via syncer agent, and post-task summary in paragraph + bullet list format.

Output: A complete `skills/build/SKILL.md` that handles the full execution lifecycle.
</objective>

<execution_context>
@/Users/noahrasheta/.claude/get-shit-done/workflows/execute-plan.md
@/Users/noahrasheta/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-execution/04-RESEARCH.md
@.planning/phases/04-execution/04-CONTEXT.md
@skills/build/SKILL.md
@skills/blueprint/SKILL.md
@agents/director-builder.md
@agents/director-syncer.md
@reference/context-management.md
@reference/terminology.md
@reference/plain-language-guide.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite build SKILL.md with complete execution pipeline</name>
  <files>skills/build/SKILL.md</files>
  <action>
Replace the entire content of `skills/build/SKILL.md` with a complete execution pipeline. The skill runs INLINE (no `context: fork`) and uses the Task tool to spawn the builder agent. It handles pre-task orchestration (routing, task selection, context assembly) and post-task orchestration (commit verification, sync, reporting) around the builder spawn.

**Frontmatter:**
```yaml
---
name: build
description: "Work on the next ready task in your project. Picks up where you left off automatically."
disable-model-invocation: true
---
```

No `context: fork` -- this skill runs inline because it needs pre/post orchestration. No `agent:` field -- the builder is spawned manually via Task tool.

**The skill must implement these 10 steps IN ORDER. Write the full content for each step as detailed below.**

---

**Step 1: Init check**
Same pattern as the existing routing: check if `.director/` exists, run init script if not, say "Director is ready." Continue to Step 2. Use the existing `!bash ${CLAUDE_PLUGIN_ROOT}/scripts/init-director.sh` pattern.

**Step 2: Vision check**
Read `.director/VISION.md`. If it only contains template placeholders (same detection as blueprint skill: `> This file will be populated when you run /director:onboard`, italic prompts like `_What are you calling this project?_`, headings with no substantive content), route to onboard. Say: "We're not ready to build yet -- you need to define what you're building first. Want to start with `/director:onboard`?" Wait for response. Stop here if no vision.

**Step 3: Gameplan check**
Read `.director/GAMEPLAN.md`. If template-only (contains `This file will be populated when you run /director:blueprint` or `_No goals defined yet_` or no real goal headings), route to blueprint. Say: "You have a vision but no gameplan yet. Want to create one with `/director:blueprint` so we know what to build first?" Wait for response. Stop here if no gameplan.

**Step 4: Find next ready task**
This is the critical task selection algorithm. Write detailed instructions:

1. Read `.director/GAMEPLAN.md` to find the current goal and step (from "Current Focus" section).
2. Read `.director/STATE.md` for progress tracking data.
3. Navigate to the current goal's current step directory: `.director/goals/NN-goal-slug/NN-step-slug/tasks/`
4. List all task files in that directory. Files ending in `.done.md` are completed -- skip them.
5. For each remaining `.md` file (in numeric order, lowest first):
   a. Read the task file.
   b. Check its "Needs First" section.
   c. If it says "Nothing" or indicates no prerequisites, the task is READY.
   d. If it lists capabilities needed, check whether those capabilities are satisfied by looking at completed tasks (`.done.md` files) and STATE.md progress.
   e. The FIRST task whose prerequisites are all met is the next ready task. Stop scanning.
6. If no tasks are ready in the current step:
   a. Check if ALL tasks in the step are `.done.md` -- if yes, the step is complete. Move to the next step in the goal.
   b. If not all done but none ready, tasks are blocked. Tell the user what's needed.
7. If no steps available in the current goal:
   a. Check if the goal is complete. Move to the next goal.
8. If all goals are complete: "Your project is done! Everything in the gameplan has been built."
9. If a ready task is found, tell the user: "Next up: [task name from the task file heading]. [One-sentence description from the task's What To Do section]." Then continue to Step 5.

If `$ARGUMENTS` is non-empty, check whether it matches a specific task name or description. If it does, use that task instead of the auto-selected one (as long as its prerequisites are met). If it doesn't match, acknowledge it and use it as extra context for the builder: "I'll keep '[arguments]' in mind while working on this."

**Step 5: Assemble context**
Build the XML-wrapped context that will be passed to the builder agent via the Task tool. Assemble each section by reading the relevant files:

1. **`<vision>`**: Read `.director/VISION.md` and wrap its full contents.
2. **`<current_step>`**: Read the STEP.md from the ready task's step directory. Wrap full contents.
3. **`<task>`**: Read the ready task file. Wrap full contents.
4. **`<recent_changes>`**: Run `git log --oneline -10 2>/dev/null` and format as a bullet list of recent progress. Wrap in tags.
5. **`<instructions>`**: Write task-specific instructions including:
   - "Complete only this task. Do not modify files outside the listed scope unless absolutely necessary."
   - "Verify your work matches the acceptance criteria before committing."
   - "Follow reference/terminology.md and reference/plain-language-guide.md for user-facing output."
   - "Create exactly one git commit when finished with a plain-language message describing what was built."
   - "After committing, spawn director-verifier to check for stubs and orphans. Fix any 'needs attention' issues and amend your commit."
   - "After verification passes, spawn director-syncer with the task context and a summary of what changed. The syncer will update STATE.md and rename the task file to .done.md."
   - If `$ARGUMENTS` was non-empty and provided extra context, include it here: "Additional context from user: [arguments]"

**Context budget calculation:** After assembling all sections, estimate the total token count using chars/4. If the total exceeds 30% of 200,000 tokens (60,000 tokens), apply truncation in this order:
1. Reduce git log to last 5 commits
2. If still over, remove reference doc instructions (keep only the file path references)
3. If still over, summarize STEP.md content instead of including full text
4. Never truncate the task file or VISION.md

Note the budget status but do not show it to the user. If truncation was applied, proceed silently.

**Step 6: Check for uncommitted changes**
Before spawning the builder, check for existing uncommitted changes: `git status --porcelain`. If there are uncommitted changes:
- Tell the user: "I noticed some unsaved changes in your project. Want me to save those first before starting this task, or set them aside temporarily?"
- If user wants to save: `git stash` the changes and note this.
- If user wants to commit: `git add -A && git commit -m "Save work in progress"` then continue.
- This prevents the task's atomic commit from including unrelated changes.

**Step 7: Spawn builder**
Use the Task tool to spawn `director-builder` with the assembled XML context as the task message. The builder will:
- Read the context
- Implement the task
- Create a git commit
- Spawn verifier and fix issues
- Spawn syncer to update docs

After the builder returns, continue to Step 8.

**Step 8: Verify builder results**
Check whether the builder completed successfully:
1. Run `git log --oneline -1` to check if a new commit was created since Step 6.
2. If a new commit exists: the task was completed. Continue to Step 9.
3. If no new commit:
   a. Check `git status --porcelain` for modified files.
   b. If files were modified but not committed: tell the user "The task was partially completed. Some changes were made but not finished. You can run `/director:build` again to try to complete it, or take a look at what was started."
   c. If no files were modified: tell the user "The task didn't get started. This might be a tricky one. Want to try again, or take a different approach?"
   d. Stop here. Do NOT create a commit for partial work.

**Step 9: Post-task sync verification**
After confirming the builder committed and the syncer ran:
1. Check if the syncer's changes need to be committed. Run `git status --porcelain` to see if there are unstaged changes in `.director/`.
2. If there are `.director/` changes from the syncer: stage and amend-commit them to maintain one commit per task:
   ```
   git add .director/
   git commit --amend --no-edit
   ```
3. Check the syncer's output for any drift it flagged (GAMEPLAN.md or VISION.md discrepancies). If drift was flagged, present it to the user:
   "I noticed something while syncing your project docs: [syncer's drift report]. Want to update your [vision/gameplan]?"
4. If no drift: proceed silently to Step 10.

Per locked decision: doc sync shows findings in plain language and asks user to confirm before applying. The syncer's STATE.md updates and .done.md renames are routine (apply automatically via amend-commit). But VISION.md or GAMEPLAN.md drift requires user confirmation before any action.

**Step 10: Post-task summary**
Present the user with a summary following the LOCKED format (paragraph + bullet list):

1. Get the list of changed files: `git diff --stat HEAD~1` (or `HEAD~1..HEAD` if there's history before).
2. Compose a plain-language paragraph describing what was built from the user's perspective. Focus on what the user can do now that they couldn't before. Connect it to what was built previously.
3. Follow with a structured bullet list under "**What changed:**" showing specific file/feature changes in plain language (NOT file paths -- describe what each change does).
4. End with: "Progress saved. You can type `/director:undo` to go back."
5. Check if the current step is now complete (all tasks are .done.md). If yes, add: "[Step name] is done! You're [X] of [Y] steps through [goal name]."
6. If more tasks remain in the step, suggest: "Next up: [next task name]. Want to keep building?"

**Language reminders at the bottom of the skill (same pattern as blueprint skill):**
- Use Director's vocabulary: Goal/Step/Task, Vision, Gameplan
- Never mention git, commits, branches, SHAs, diffs to the user
- Say "Progress saved" not "Changes committed"
- Say "needs X first" not "blocked by" or "depends on"
- File operations are invisible: never show file paths in output
- Be conversational, match user's energy
- Follow reference/terminology.md and reference/plain-language-guide.md

Include `$ARGUMENTS` at the very end of the skill (after the language reminders), same pattern as blueprint.

**Important implementation notes from research:**
- The skill does NOT use `context: fork` -- it runs inline. This is because it needs to do pre-task work (steps 1-6) and post-task work (steps 8-10) around the builder spawn.
- The builder is spawned via `Task(director-builder)` with the assembled XML context as the message.
- The syncer is spawned BY THE BUILDER (not by the skill directly). The builder's instructions tell it to spawn the syncer after verification passes. However, the skill handles the amend-commit of syncer changes in Step 9.
- Per locked decision: external change detection (manual edits, other tools) only happens on `/director:resume`, NOT in this build flow. Per-task sync focuses on the task's own changes only.
  </action>
  <verify>
Read `skills/build/SKILL.md` and confirm:
1. Frontmatter has `disable-model-invocation: true` and NO `context: fork`
2. Step 4 implements ready task detection by scanning .done.md files and checking Needs First
3. Step 5 assembles XML context with all 5 tags (vision, current_step, task, recent_changes, instructions)
4. Step 5 includes context budget calculation (chars/4, 30% threshold, truncation strategy)
5. Step 6 checks for uncommitted changes before spawning
6. Step 7 spawns director-builder via Task tool with assembled context
7. Step 8 checks for successful commit and handles partial failure
8. Step 9 amend-commits syncer changes and handles drift reporting
9. Step 10 uses paragraph + bullet list format with "Progress saved" message
10. Language reminders section exists at bottom
11. $ARGUMENTS is included at the end
12. The skill is at least 250 lines
  </verify>
  <done>Build skill implements the complete execution pipeline: routing, task selection, context assembly with budget calculator, builder spawning, atomic commit, doc sync with amend-commit, and post-task summary in paragraph + bullet list format</done>
</task>

</tasks>

<verification>
- Build skill covers all 9 EXEC requirements:
  - EXEC-01: Step 4 finds next ready task
  - EXEC-02: Step 5 assembles fresh context (VISION.md, STEP.md, task file, git history)
  - EXEC-03: Step 5 uses XML boundary tags
  - EXEC-04: Steps 7-9 produce exactly one atomic commit (with amend for sync changes)
  - EXEC-05: Step 10 shows "Progress saved" language
  - EXEC-06: Step 9 runs doc sync after task
  - EXEC-07: External change detection is explicitly deferred to /director:resume per locked decision
  - EXEC-08: Step 10 reports in plain language (paragraph + bullets)
  - EXEC-09: Step 7 spawns builder which can spawn verifier, syncer, researcher
- Skill follows established patterns from blueprint skill (init check, vision check, gameplan check, $ARGUMENTS, language reminders)
- All locked decisions honored: doc sync reporting shows diffs and asks confirmation; external changes only on resume; post-task summary is paragraph + bullets
- No deferred ideas implemented (none existed)
</verification>

<success_criteria>
- `skills/build/SKILL.md` contains a complete 10-step execution pipeline
- Ready task detection scans gameplan hierarchy using .done.md convention
- Context assembly wraps content in XML boundary tags with budget calculator
- Builder is spawned via Task tool (not context: fork)
- Atomic commit maintained via amend-commit for syncer changes
- Post-task summary follows locked format: paragraph + bullet list + "Progress saved"
- All 9 EXEC requirements (EXEC-01 through EXEC-09) are addressed
</success_criteria>

<output>
After completion, create `.planning/phases/04-execution/04-02-SUMMARY.md`
</output>
