---
phase: 05-verification
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - skills/build/SKILL.md
autonomous: true

must_haves:
  truths:
    - "After a task completes, Tier 1 verification results are invisible to the user if everything passes"
    - "When verification finds remaining issues, they are presented in two-severity format (Needs attention / Worth checking)"
    - "Auto-fixable issues are offered for fix only after user consent"
    - "Auto-fix retry loop spawns debugger then re-verifies, with per-issue retry cap"
    - "When all tasks in a step become .done.md, Tier 2 behavioral checklist is generated and presented"
    - "Goal completion triggers a broader checklist and bigger celebration"
    - "Partial Tier 2 passes lead with wins before flagging issues"
  artifacts:
    - path: "skills/build/SKILL.md"
      provides: "Complete verification flow in build pipeline Steps 8-10"
      contains: "auto-fix"
    - path: "skills/build/SKILL.md"
      provides: "Step boundary detection logic"
      contains: ".done.md"
    - path: "skills/build/SKILL.md"
      provides: "Tier 2 behavioral checklist generation"
      contains: "checklist"
  key_links:
    - from: "skills/build/SKILL.md"
      to: "agents/director-builder.md"
      via: "Step 8b reads builder output for 'Verification:' status line"
      pattern: "Verification:"
    - from: "skills/build/SKILL.md"
      to: "agents/director-debugger.md"
      via: "Step 8c spawns debugger with issue context via Task tool"
      pattern: "director-debugger"
    - from: "skills/build/SKILL.md"
      to: "agents/director-verifier.md"
      via: "Step 8c re-spawns verifier after debugger fix to confirm resolution"
      pattern: "director-verifier"
---

<objective>
Rewrite the build skill's post-task flow (Steps 8-10) to surface verification results, orchestrate auto-fix retry loops with user consent, detect step/goal boundaries, and trigger Tier 2 behavioral checklists with celebration feedback.

Purpose: Currently the build skill checks for a commit (Step 8), amend-commits syncer changes (Step 9), and shows a summary (Step 10). Phase 5 expands this to: parse builder verification status, present remaining issues in two-severity format, offer consent-based auto-fix using debugger agents, detect when a step or goal is complete, generate and present Tier 2 behavioral checklists, and celebrate progress at boundaries. This is the core of the verification user experience.

Output: Updated `skills/build/SKILL.md` with expanded Steps 8-10
</objective>

<execution_context>
@/Users/noahrasheta/.claude/get-shit-done/workflows/execute-plan.md
@/Users/noahrasheta/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-verification/05-CONTEXT.md
@.planning/phases/05-verification/05-RESEARCH.md
@.planning/phases/05-verification/05-01-SUMMARY.md
@skills/build/SKILL.md
@agents/director-builder.md
@agents/director-verifier.md
@agents/director-debugger.md
@reference/verification-patterns.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite build skill Steps 8-10 with verification flow, auto-fix loop, boundary detection, and Tier 2 checklists</name>
  <files>skills/build/SKILL.md</files>
  <action>
Rewrite Steps 8, 9, and 10 of skills/build/SKILL.md. Steps 1-7 and the Language Reminders section remain EXACTLY as they are. Only replace Steps 8, 9, and 10.

**Step 8: Verify builder results**

Break into sub-steps:

### 8a: Check for a new commit
Same logic as current Step 8a -- run `git log --oneline -1`, compare to pre-builder commit. If no new commit, handle partial/total failure exactly as current Step 8b. If commit exists, continue.

### 8b: Parse verification results
Read the builder's output for the verification status line:

- If "Verification: clean" -- verification passed. Continue silently to Step 9. Do NOT show any verification message to the user (locked decision: Tier 1 invisible unless issues found).
- If "Verification: N issues found, all fixed" -- builder handled everything internally. Continue silently to Step 9.
- If "Verification: N issues found, M fixed, R remaining" -- issues survived the builder's pass. Continue to 8c.

### 8c: Present remaining issues to user
Classify each remaining issue from the builder's output:

Group into two sections following the locked decision format:

**"Needs attention"** section -- blocking issues that should be fixed:
Present each with: what + why + where (locked decision tone: confident assistant, direct and efficient)
Example: "The settings page has placeholder content in the header section -- users would see 'TODO' text."

**"Worth checking"** section -- informational items:
Present with plain-language description.

For each "Needs attention" issue, check whether it was marked auto-fixable by the builder/verifier:
- Auto-fixable issues: stubs, broken wiring, placeholder content, missing imports
- Report-only issues: missing features, design decisions, architectural changes, human judgment needed

If ANY auto-fixable issues exist:
> "I can fix [N] of these automatically. Want me to try?"

Wait for user response.

- If user approves: continue to 8d.
- If user declines: note the issues and continue to Step 9.

### 8d: Auto-fix retry loop
For each auto-fixable "Needs attention" issue, run a fix cycle:

1. Show progress update: "Investigating the issue..."
2. Spawn `director-debugger` via Task tool with assembled context:
   ```xml
   <task>[Original task file content]</task>
   <issues>[The specific issue being fixed, with location and context]</issues>
   <instructions>Fix this issue. This is attempt [N] of [max]. [If retry 2+: "Previous attempt tried [X] but it didn't work. Try a different approach."]</instructions>
   ```
3. Read debugger output and check Status line:
   - "Status: Fixed" -- show "Found the cause... Applying fix (attempt N of max)... Fixed!" Then spawn `director-verifier` via Task tool to re-check the specific area. If re-check passes, run `git add -A && git commit --amend --no-edit` to include the fix in the task commit. Move to next issue.
   - "Status: Needs more work" -- increment retry counter. If under max retries, show "Trying a different approach (attempt N of max)..." and loop back to step 1.
   - "Status: Needs manual attention" -- stop retrying this issue. Report what the debugger found and suggest next steps.

4. If max retries reached for an issue: explain what was tried and suggest manual fix:
   > "I tried [N] approaches to fix [issue description] but couldn't resolve it. Here's what I found: [debugger's diagnosis]. You might want to [suggestion]."

Retry cap per issue (Claude's Discretion -- decide based on issue complexity):
- Simple wiring fixes (missing import, wrong path): 2 retries max
- Placeholder/stub replacement: 3 retries max
- Complex integration issues: 3-5 retries max

After all auto-fixable issues are addressed (fixed or given up), continue to Step 9.

**Step 9: Post-task sync verification**

Keep the EXISTING Step 9 logic exactly as-is (9a: check for uncommitted sync changes, amend-commit; 9b: check for drift, present to user). No changes needed.

**Step 10: Post-task summary and boundary check**

Keep existing 10a (get change details), 10b (compose summary), and 10c (progress saved) exactly as-is.

Replace the existing 10d with a much more detailed boundary detection and Tier 2 flow:

### 10d: Step and goal boundary detection

After presenting the post-task summary:

1. List all files in the current step's `tasks/` directory.
2. Count total `.md` files (both regular and `.done.md`) and count `.done.md` files specifically.
3. If NOT all task files end in `.done.md`: the step is incomplete.
   > "Next up: [next task name from the first non-.done.md file]. Want to keep building?"
   Stop here.

4. If ALL task files end in `.done.md`: the step is complete.
   Check whether all steps in the current goal directory are complete (each step's `tasks/` directory has all `.done.md` files).
   - If all steps complete: GOAL IS COMPLETE -- use the goal-level flow below.
   - If not all steps complete: STEP COMPLETE ONLY -- use the step-level flow below.

### 10e: Tier 2 behavioral checklist (step complete)

When a step is complete, generate a behavioral checklist for the user to verify:

1. Read the completed step's `STEP.md`
2. Read all `.done.md` task files in the step (to understand what was actually built)
3. Read `VISION.md` for overall project context
4. Read `git log --oneline` for commits in this step's tasks (to capture what was actually done vs. planned)

Generate a behavioral checklist where each item is something the user can try and observe. Write items as plain-language instructions: "Try X. What happens?" or "Open Y and check that Z." Size the checklist based on step complexity (Claude's Discretion: small steps with 2-3 tasks get 3-5 items, larger steps get 5-8 items).

Present the checklist:
> "[Step name] is done! Here's a quick checklist to make sure everything works:
>
> 1. [Testable action with expected result]
> 2. [Testable action with expected result]
> ...
>
> Try these out and let me know how they go!"

Wait for user response. Interpret their natural-language answers to determine which items passed and which failed.

**If ALL items pass:**
> "[Outcome statement]! That's [step name] done -- you're [X] of [Y] steps through [goal name]."

**If SOME items fail (lead with wins per locked decision):**
> "[N] of [M] checks passed! [Items that failed] need attention:
> - [Issue description with why it matters]"

If failed items are auto-fixable, offer auto-fix (same consent flow as 8c/8d).
If not auto-fixable, describe the issue and suggest what to do.

The checklist is guidance, not a gate. If the user wants to continue building without completing the checklist, let them.

### 10f: Tier 2 behavioral checklist (goal complete)

When a goal is complete, this is a bigger moment (locked decision):

1. Read the goal's `GOAL.md` (if it exists)
2. Read all step STEP.md files in the goal
3. Read all `.done.md` task files across all steps
4. Read `VISION.md`

Generate a broader behavioral checklist that tests cross-step integration. These items should verify that features from different steps work together.

Present with a summary of everything built:
> "[Goal name] is complete! Here's everything that was built:
> - [Step 1 summary -- one sentence about what it delivered]
> - [Step 2 summary]
> - ...
>
> Let's verify everything works together:
>
> 1. [Goal-level testable action]
> 2. [Goal-level testable action]
> ...
>
> Try these out and let me know!"

Wait for user response. Process results same as step-level.

**If all pass:**
> "That's a big milestone -- [goal name] is done! [Total progress: X of Y goals complete]. [What's next: brief description of next goal, or 'Your project is complete!' if all goals done]."

**If some fail:** Lead with wins, flag issues, offer auto-fix if applicable.

**IMPORTANT:** The celebration message comes AFTER Tier 2 results are in, not before. Celebrate the outcome ("User authentication is working!"), not just the task completion.
  </action>
  <verify>
Read skills/build/SKILL.md and confirm:
1. Steps 1-7 are unchanged from the original
2. Step 8 has sub-steps 8a (commit check), 8b (parse verification), 8c (present issues), 8d (auto-fix loop)
3. Step 8b handles three verification status formats (clean, all fixed, remaining)
4. Step 8c uses two-severity format (Needs attention / Worth checking)
5. Step 8c offers auto-fix only for auto-fixable issues, with user consent
6. Step 8d spawns debugger, reads status, handles Fixed/Needs more work/Needs manual attention
7. Step 8d has per-issue retry cap with complexity-based limits
8. Step 9 is unchanged (sync verification)
9. Step 10 has 10a-10c unchanged, plus new 10d (boundary detection), 10e (step Tier 2), 10f (goal Tier 2)
10. 10d checks .done.md files to detect step/goal completion
11. 10e generates step-level behavioral checklist
12. 10f generates goal-level behavioral checklist with summary and bigger celebration
13. Celebration timing: AFTER Tier 2 results, not before
14. Partial passes lead with wins (locked decision)
15. Language Reminders section is unchanged
  </verify>
  <done>Build skill has complete post-task verification flow: invisible Tier 1 on success, two-severity issue presentation, consent-based auto-fix with debugger retry loop, step/goal boundary detection with Tier 2 behavioral checklists, and celebration that combines outcome + progress</done>
</task>

</tasks>

<verification>
The build skill's post-task flow handles all verification scenarios:
1. Clean verification -- silent, invisible to user
2. Builder-fixed issues -- silent, invisible to user
3. Remaining issues -- presented in two-severity format with auto-fix offer
4. Auto-fix -- debugger spawned with retry loop, re-verification after each fix
5. Step boundary -- Tier 2 checklist generated and presented
6. Goal boundary -- broader checklist with celebration
7. Partial passes -- lead with wins per locked decision
</verification>

<success_criteria>
- Tier 1 verification is invisible when everything passes (VRFY-04)
- Issues presented in two-severity format with auto-fix offer (VRFY-07, VRFY-08)
- Auto-fix uses debugger agents with retry cap (VRFY-08, VRFY-09)
- User always asked before auto-fix begins (locked decision)
- Step boundaries trigger Tier 2 behavioral checklist (VRFY-05, VRFY-06)
- Goal boundaries get bigger celebration with progress summary (locked decision)
- Partial passes lead with wins (locked decision)
- Steps 1-7 and 9 are unchanged from Phase 4
</success_criteria>

<output>
After completion, create `.planning/phases/05-verification/05-02-SUMMARY.md`
</output>
