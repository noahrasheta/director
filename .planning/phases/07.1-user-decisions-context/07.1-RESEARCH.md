# Phase 7.1: User Decisions Context - Research

**Researched:** 2026-02-08
**Domain:** Claude Code skill authoring (prompt-driven STEP.md template, context assembly, decision capture in blueprint conversation)
**Confidence:** HIGH

## Summary

Phase 7.1 closes a specific gap in Director's workflow: when a task executes in a fresh agent window, the builder has no knowledge of what the user decided during the blueprint conversation. The user may have said "use Tailwind, not styled-components" or "keep the API simple, no GraphQL" -- but by the time the builder spawns, that conversation is gone. This phase adds a Decisions section to STEP.md that persists user intent across fresh context boundaries.

The work touches three existing files: the STEP.md template (add Decisions section), the build skill (load decisions into context assembly), and the blueprint skill (capture decisions during planning). No new files, no new agents, no new commands. The scope is narrow and well-defined. The main design challenge is making the blueprint skill's decision capture feel natural within the existing conversational flow rather than adding an interrogation step.

This phase depends on Phase 7 being complete. Phase 7 modifies the quick skill, idea skill, and creates the ideas skill -- but does NOT modify the blueprint skill, build skill, or step template. So Phase 7.1 can cleanly modify those files without merge conflicts.

**Primary recommendation:** Structure as 3 plans following the roadmap stubs: (1) STEP.md template update with planner rules for populating decisions, (2) build skill context assembly update to load and wrap decisions, (3) blueprint skill update to capture decisions during the planning conversation.

## Standard Stack

This phase does not introduce new libraries or external dependencies. All work is prompt engineering in Markdown skill files and template updates.

### Core Components
| Component | Type | Purpose | Changes Needed |
|-----------|------|---------|----------------|
| `skills/blueprint/templates/step-template.md` | Template | Generates STEP.md for each step | Add Decisions section with Locked/Flexible/Deferred categories |
| `skills/build/SKILL.md` | Skill file | Assembles context for builder agent | Add decisions loading in Step 5 context assembly |
| `skills/blueprint/SKILL.md` | Skill file | Blueprint planning conversation | Add step-level decision capture during hierarchy generation |
| `agents/director-planner.md` | Agent | Creates gameplan structure | May need awareness of Decisions section for STEP.md generation |
| `agents/director-builder.md` | Agent | Receives assembled context | Needs to understand `<decisions>` XML tag semantics |
| `reference/context-management.md` | Reference | Documents context assembly patterns | Add `<decisions>` tag to standard tags table |

### Files NOT Modified
| File | Why Not |
|------|---------|
| `skills/quick/SKILL.md` | Quick mode has no step or decisions -- it's outside the gameplan hierarchy |
| `skills/ideas/SKILL.md` | Ideas routing is separate from the build pipeline |
| `agents/director-verifier.md` | Verifier does not need decision context |
| `agents/director-syncer.md` | Syncer does not need decision context |

## Architecture Patterns

### Pattern 1: Decisions Section in STEP.md

The Decisions section sits after the existing sections in STEP.md. It uses three categories that map directly to the user's level of specificity during the blueprint conversation.

**Current STEP.md structure:**
```markdown
# Step N: [Step Name]

## What This Delivers
[description]

## Tasks
- [ ] Task 1: [name]
- [ ] Task 2: [name]

## Needs First
[prerequisites]
```

**Updated STEP.md structure:**
```markdown
# Step N: [Step Name]

## What This Delivers
[description]

## Tasks
- [ ] Task 1: [name]
- [ ] Task 2: [name]

## Needs First
[prerequisites]

## Decisions

### Locked
[User explicitly decided these -- follow exactly, no deviation]

- [decision 1 in plain language]
- [decision 2 in plain language]

### Flexible
[User has no strong preference -- use your best judgment]

- [area 1 where builder can choose]
- [area 2 where builder can choose]

### Deferred
[Out of scope for this step -- do not implement]

- [deferred item 1]
- [deferred item 2]
```

**Why this structure works:**
- **Locked** = non-negotiable. The user said "use X" and meant it. The builder must honor this exactly.
- **Flexible** = AI discretion. The user said "I don't care how you do it" or didn't express a preference. The builder can make the best choice.
- **Deferred** = explicit scope boundary. The user said "not now" or "save that for later." The builder must not implement these even if they seem related.

**When the section is empty or absent:**
- If no decisions were captured during blueprint, the Decisions section can be omitted entirely from the STEP.md.
- The build skill must handle this gracefully -- if no `## Decisions` heading exists in STEP.md, skip the decisions context section with no errors.

### Pattern 2: Decisions in Context Assembly (Build Skill)

The build skill's Step 5 (context assembly) currently assembles five XML sections: `<vision>`, `<current_step>`, `<task>`, `<recent_changes>`, `<instructions>`. Phase 7.1 adds a sixth section: `<decisions>`.

**New section positioned between `<current_step>` and `<task>`:**

```xml
<vision>
[Full contents of VISION.md]
</vision>

<current_step>
[Full contents of STEP.md]
</current_step>

<decisions>
These are the user's decisions for this step. Follow them exactly:

**Locked (non-negotiable):**
- [decision 1]
- [decision 2]

**Flexible (your judgment):**
- [area 1]
- [area 2]

**Deferred (do NOT implement):**
- [deferred item 1]
- [deferred item 2]
</decisions>

<task>
[Full contents of the task file]
</task>

<recent_changes>
[git log]
</recent_changes>

<instructions>
[task-specific instructions]
[NEW: "Honor all Locked decisions exactly. Use your judgment on Flexible items. Do NOT implement anything listed as Deferred."]
</instructions>
```

**Why between `<current_step>` and `<task>`:**
- Follows the context assembly tag ordering rule: "vision first, then scoping (step/task), then context (changes/state), then instructions last"
- Decisions are step-level scoping -- they narrow the builder's freedom within the step, before the builder reads the specific task
- The builder reads vision (big picture) -> step (what this chunk delivers) -> decisions (constraints on how to deliver it) -> task (specific work) -> instructions (rules)

**Extraction logic:**
The build skill reads the STEP.md file. If it contains a `## Decisions` heading, extract everything from that heading through the end of the file (or until the next top-level heading, though in practice Decisions should be the last section). Wrap it in `<decisions>` tags with the preamble instruction line.

**Backward compatibility:**
If STEP.md has no `## Decisions` heading, skip the `<decisions>` section entirely. No empty tags, no placeholder text. The builder operates exactly as it does today -- full AI discretion within the task's scope.

### Pattern 3: Decision Capture in Blueprint Conversation

The blueprint skill currently has a two-phase conversation flow:
1. **Phase 1:** Generate and review goals (user approves goal set)
2. **Phase 2:** Generate full hierarchy (user approves steps and tasks)

Decision capture happens naturally during this conversation. The user often says things like:
- "Use Supabase for the database" (Locked)
- "I don't care about the styling approach" (Flexible)
- "Don't worry about dark mode for now" (Deferred)

**The blueprint skill should extract these during Phase 2 (hierarchy generation).** After the user approves the full hierarchy and before writing files, the skill should:

1. Review the conversation for any decisions the user made about implementation approach, tech choices, design direction, or scope boundaries.
2. Assign each decision to the step it most affects.
3. Categorize each as Locked, Flexible, or Deferred.
4. Include the Decisions section when writing each STEP.md file.

**Important: This should NOT be an explicit interrogation step.** The blueprint skill should not ask "What decisions have you made for Step 1?" That breaks the conversational flow. Instead, it passively extracts decisions from the natural conversation and includes them in the STEP.md files it generates. The user already expressed these preferences -- the skill just captures them.

**For update mode:** When running `/director:blueprint` on an existing gameplan, the skill should also capture any new decisions from the update conversation and merge them with existing decisions in the STEP.md files. Existing decisions in completed steps are FROZEN (same rule as completed work).

### Pattern 4: Builder Agent Decision Awareness

The builder agent (`agents/director-builder.md`) needs to understand the `<decisions>` tag. Add a line to the "Context You Receive" section:

```markdown
- `<decisions>` -- User decisions for this step. Locked items are non-negotiable.
  Flexible items are your choice. Deferred items are out of scope -- do not implement them.
```

And add a rule to the "Execution Rules" section:

```markdown
N. **Honor user decisions.** If `<decisions>` is present:
   - **Locked:** Follow these exactly. If a locked decision says "use Tailwind",
     use Tailwind even if you'd prefer a different approach.
   - **Flexible:** Use your best judgment. These are areas where the user trusts you.
   - **Deferred:** Do NOT implement these, even partially, even if they seem related
     to the current task. They are explicitly out of scope.
```

### Pattern 5: Context Budget Impact

The Decisions section adds minimal tokens to the context budget. A typical STEP.md Decisions section is 10-20 lines (200-400 characters, ~50-100 tokens). This is well within the 60K token budget threshold.

The decisions content is included as part of the `<current_step>` extraction OR as a separate `<decisions>` tag. Either approach works for budget purposes. The separate tag approach is cleaner because:
- It makes decisions visually distinct in the assembled context
- The builder can find decisions quickly without parsing the full STEP.md
- The truncation strategy can treat it independently (though it should never be truncated -- decisions are essential)

**Truncation rule:** Never truncate the `<decisions>` section. It is as essential as the task file and vision. Add it to the "Never truncate" list alongside task and vision in the context management reference.

### Anti-Patterns to Avoid

- **Don't make decision capture an interrogation.** The blueprint conversation already surfaces decisions naturally. Adding "What are your decisions for Step 1?" feels bureaucratic and breaks the vibe coder experience.
- **Don't require decisions for every step.** Many steps need no explicit decisions -- the builder can use full AI discretion. The Decisions section should be omitted entirely when there is nothing to capture.
- **Don't nest decisions inside task files.** Decisions are step-level, not task-level. A decision like "use Tailwind" applies to the entire step, not individual tasks. Keeping decisions in STEP.md avoids duplication across task files.
- **Don't create a separate decisions file.** A `DECISIONS.md` alongside STEP.md would add file proliferation. Decisions are a section of STEP.md, consistent with Director's existing file structure.
- **Don't duplicate decisions in the `<instructions>` tag.** The instructions tag should reference decisions (e.g., "Honor all Locked decisions") but not repeat the content. The `<decisions>` tag already has the full list.
- **Don't extract decisions from vision.** VISION.md already flows to the builder. Decisions in STEP.md are step-specific choices that go beyond vision-level guidance.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Decision storage format | Custom JSON/YAML decision tracking | Markdown section in STEP.md | Director uses Markdown for all user-facing artifacts; decisions are user-readable |
| Decision extraction from conversation | NLP-based intent classifier | Blueprint skill passively extracts from conversation context | The AI already understands the conversation; it just needs instructions to capture decisions |
| Decision validation | Schema validation for decision format | Plain-language bullet list | Over-engineering; the builder is an AI that reads natural language |
| Separate decision inheritance | Complex cascading from goal -> step -> task | Step-level only, vision provides goal-level context | Simplest design that solves the problem |

**Key insight:** Decisions are just structured notes from the blueprint conversation. They do not need formal data structures, validation, or inheritance hierarchies. A bulleted Markdown list that the builder can read is sufficient.

## Common Pitfalls

### Pitfall 1: Over-capturing decisions
**What goes wrong:** The blueprint skill lists every statement the user made as a "decision," creating a Decisions section that is 50+ lines of noise.
**Why it happens:** Without clear criteria for what constitutes a decision, the skill might capture conversational asides as decisions.
**How to avoid:** Define clear criteria in the blueprint skill: a decision is a statement about HOW something should be built (tech choice, approach, constraint, scope boundary). General project description, feature requests, and goal definitions are NOT decisions -- they belong in the vision and task descriptions.
**Warning signs:** Decisions sections that repeat information already in the task description or vision.

### Pitfall 2: Decisions contradicting task files
**What goes wrong:** A Locked decision says "use REST API" but a task file says "Set up GraphQL endpoint." The builder gets contradictory instructions.
**Why it happens:** The blueprint skill generates tasks independently from decision capture, or the user changed their mind after initial planning.
**How to avoid:** Decisions are captured FROM the same conversation that generates tasks. If the user says "use REST" and the tasks reflect that, the decision is redundant but harmless. If there is a true contradiction, the builder should follow Locked decisions over task descriptions (since decisions represent explicit user intent).
**Warning signs:** Builder output that ignores locked decisions.

### Pitfall 3: Stale decisions after blueprint update
**What goes wrong:** User runs `/director:blueprint "switch to PostgreSQL"` but old decisions in STEP.md still say "use SQLite."
**Why it happens:** Blueprint update mode modifies tasks but does not review/update existing decisions.
**How to avoid:** When the blueprint skill runs in update mode, it must review existing Decisions sections in modified steps and update them to reflect the new conversation. Completed steps are FROZEN (including their decisions).
**Warning signs:** Steps with outdated decisions after a blueprint update.

### Pitfall 4: Builder ignoring decisions because they are buried
**What goes wrong:** The builder does not follow Locked decisions because the `<decisions>` content was lost in a large STEP.md.
**Why it happens:** If decisions are embedded within `<current_step>` rather than a separate `<decisions>` tag, the builder may not notice them.
**How to avoid:** Use a separate `<decisions>` XML tag with an explicit preamble instruction. Also add a reinforcing line in `<instructions>`: "Honor all Locked decisions exactly."
**Warning signs:** Builder output that contradicts Locked decisions.

### Pitfall 5: Backward compatibility gap
**What goes wrong:** Existing STEP.md files from Phases 1-7 (without Decisions sections) cause errors in the build skill after Phase 7.1 updates.
**Why it happens:** The build skill tries to extract a Decisions section that does not exist.
**How to avoid:** The build skill must check for the existence of `## Decisions` in STEP.md before attempting extraction. If absent, skip the `<decisions>` tag entirely. This is a mandatory backward-compatibility check.
**Warning signs:** Errors or empty `<decisions>` tags when building tasks from pre-7.1 STEP.md files.

### Pitfall 6: Decisions section placement in template
**What goes wrong:** The Decisions section is placed before Tasks or Needs First, causing confusion about the template structure.
**Why it happens:** Unclear template ordering.
**How to avoid:** Decisions goes LAST in the STEP.md template, after Needs First. This preserves the natural reading flow: what the step delivers -> what tasks it contains -> what it needs first -> what decisions constrain it. The decisions are an addendum, not a primary section.
**Warning signs:** Users confused about STEP.md structure.

## Code Examples

### Updated STEP.md Template
```markdown
# Step N: [Step Name]

## What This Delivers

_What will be working or available when this step is done?_

## Tasks

- [ ] Task 1: [Task Name]
- [ ] Task 2: [Task Name]
- [ ] Task 3: [Task Name]

## Needs First

_What needs to be done before this step can start? Write in plain language._

_Example: "The database needs to be set up first (Step 1)."_
_If nothing is needed, write: "Nothing -- this step can start right away."_

## Decisions

### Locked
_Choices the user explicitly made -- follow these exactly._

### Flexible
_Areas where the builder can use its best judgment._

### Deferred
_Ideas mentioned but explicitly set aside -- do not implement._
```

### Build Skill Step 5 Addition (Decisions Loading)
```markdown
### 5b-alt: Decisions (NEW -- after current step, before task)

Check the STEP.md content (already read in Step 5b) for a `## Decisions` heading.

**If a Decisions heading exists:**

Extract everything from `## Decisions` through the end of the file. Wrap it:

\```
<decisions>
These are the user's decisions for this step. Follow them exactly:

[Extracted Decisions content from STEP.md]

RULES:
- Locked items are non-negotiable -- follow them exactly as stated.
- Flexible items are your choice -- use your best judgment.
- Deferred items are out of scope -- do NOT implement them, even partially.
</decisions>
\```

**If no Decisions heading exists:**

Skip this section entirely. Do not include an empty `<decisions>` tag.
Continue to Step 5c (task).
```

### Blueprint Skill Decision Capture Addition
```markdown
### Capture Step-Level Decisions

After the user approves the full hierarchy outline and before writing files:

1. Review the entire conversation for statements the user made about:
   - Technology choices ("use Supabase", "stick with REST")
   - Design direction ("keep the UI simple", "no animations")
   - Implementation approach ("server-side rendering", "use existing auth")
   - Scope boundaries ("skip dark mode for now", "don't worry about mobile")

2. For each decision, determine which step it most affects.

3. Categorize each decision:
   - **Locked:** User said "use X" or "I want Y" or "make sure Z" -- explicit directive
   - **Flexible:** User said "I don't care about X" or "whatever works" or simply did not express a preference on a choice point
   - **Deferred:** User said "not now" or "save for later" or "skip X for now"

4. When writing each STEP.md file, include the Decisions section with the relevant decisions for that step.

5. If a step has no relevant decisions from the conversation, OMIT the Decisions section entirely. Do not write empty categories.

**Important:** Do NOT ask the user to enumerate their decisions. Extract them from the natural conversation. This should be invisible to the user -- they see their gameplan written, and the decisions they expressed are captured in the STEP.md files without any additional interaction.
```

### Builder Agent Decision Awareness Addition
```markdown
## Context You Receive
[existing items...]
- `<decisions>` -- User decisions for this step. Locked items are non-negotiable.
  Flexible items are your choice. Deferred items are out of scope -- do not
  implement them.
```

```markdown
## Execution Rules
[existing rules 1-8...]

9. **Honor user decisions.** If `<decisions>` is present in your context:
   - **Locked:** Follow these exactly. If a locked decision says "use Tailwind",
     use Tailwind even if you would prefer a different approach.
   - **Flexible:** Use your best judgment. The user trusts your expertise here.
   - **Deferred:** Do NOT implement these, even partially. They are explicitly
     out of scope for this step, even if they seem related to your task.
   If no `<decisions>` section is present, use your best judgment for all
   implementation choices.
```

### Context Management Reference Update
```markdown
## XML Boundary Tags

| Tag | Content | When Included |
|----|----|----|
| `<vision>` | Contents of VISION.md | Always |
| `<current_step>` | Contents of STEP.md | Always during build |
| `<decisions>` | User decisions from STEP.md | During build, if STEP.md has Decisions section |
| `<task>` | Task description | Always during build |
| `<recent_changes>` | Recent git log | Always |
| `<instructions>` | Task constraints | Always |
```

## State of the Art

| Old Approach (Pre-7.1) | Current Approach (Phase 7.1) | Impact |
|-------------------------|------------------------------|--------|
| User decisions lost after blueprint conversation ends | Decisions persisted in STEP.md and loaded into builder context | Builder follows user intent without needing the original conversation |
| Builder makes all implementation choices with no user guidance | Builder distinguishes Locked/Flexible/Deferred decisions | User gets exactly what they asked for on things they care about |
| STEP.md has no decisions section | STEP.md has optional Decisions section with three categories | Step-level user intent preserved across fresh context boundaries |

## Open Questions

1. **Should the blueprint skill present extracted decisions to the user for review?**
   - What we know: The current design has the skill passively extracting decisions and writing them into STEP.md files without additional user interaction.
   - What's unclear: Should the skill show the user "Here are the decisions I captured from our conversation" before writing files? This adds transparency but also adds a confirmation step to an already two-phase process.
   - Recommendation: Do NOT add a separate confirmation step. The decisions are derived from the conversation the user just had -- they already expressed these preferences. Adding a review step makes the blueprint flow feel bureaucratic. If a decision is wrong, the user can see it in STEP.md and update it manually or via blueprint update mode.

2. **Should Flexible items include specific options?**
   - What we know: "Flexible" means the user has no strong preference and the builder can choose.
   - What's unclear: Should Flexible items say "Styling approach (Tailwind, CSS Modules, or styled-components)" or just "Styling approach"?
   - Recommendation: Include brief context when available from the conversation ("Styling approach -- user has no preference"), but do not enumerate options. The builder is capable of making good choices without being given a multiple-choice menu.

3. **Should decisions propagate from goal to step level?**
   - What we know: Decisions are captured at step granularity. VISION.md provides goal/project-level context.
   - What's unclear: If a user says "use PostgreSQL for everything" during blueprint, should this decision appear in every step that involves a database?
   - Recommendation: Yes, the blueprint skill should propagate cross-cutting decisions to all relevant steps. A decision like "use PostgreSQL" is relevant to any step involving data storage. The skill should duplicate it into each affected STEP.md rather than creating a separate inheritance mechanism.

## Sources

### Primary (HIGH confidence)
- **Existing codebase analysis** -- All files read directly from the repository at `/Users/noahrasheta/Dev/GitHub/director/`
- **`skills/blueprint/templates/step-template.md`** -- Current STEP.md template (19 lines, no Decisions section)
- **`skills/build/SKILL.md`** -- Current build skill with full 10-step pipeline (494 lines)
- **`skills/blueprint/SKILL.md`** -- Current blueprint skill with two-phase flow and update mode (549 lines)
- **`agents/director-builder.md`** -- Current builder agent definition (119 lines)
- **`agents/director-planner.md`** -- Current planner agent definition (147 lines)
- **`reference/context-management.md`** -- Current context assembly documentation (243 lines)

### Secondary (HIGH confidence)
- **Phase 7 research and plans** -- Verified Phase 7 does not modify any files that Phase 7.1 touches (blueprint, build, step template, builder agent)
- **Prior STATE.md decisions** -- Decision patterns established across Phases 1-6 inform design choices

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH -- no new components, modifies known files with known patterns
- Architecture: HIGH -- three clear modifications to existing artifacts, well-understood context assembly system
- Pitfalls: HIGH -- identified from direct analysis of existing code and decision flow
- Code examples: HIGH -- based on existing patterns in the codebase, verified against current file contents

**Research date:** 2026-02-08
**Valid until:** 2026-03-08 (stable -- plugin authoring patterns do not change rapidly)
